import{_ as e,r as t,o,c as p,a as n,b as s,d as c,f as i}from"./app-5uqBhi11.js";const l={},r=n("h1",{id:"正则表达式",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#正则表达式","aria-hidden":"true"},"#"),s(" 正则表达式")],-1),u=n("h2",{id:"定位",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#定位","aria-hidden":"true"},"#"),s(" 定位")],-1),d={href:"https://blog.csdn.net/csm0912/article/details/81206848",target:"_blank",rel:"noopener noreferrer"},k=i(`<blockquote><p><code>?=、?&lt;=、?!、?&lt;!</code>相关的正则表达式只是辅助匹配，它们本身不会匹配出任何内容，像这类的正则表达式我们也称之为零宽断言，它们存在的意义也只是为了定位。</p></blockquote><h2 id="零宽正向先行断言" tabindex="-1"><a class="header-anchor" href="#零宽正向先行断言" aria-hidden="true">#</a> 零宽正向先行断言</h2><p><strong><em>断言</em></strong> 的意思是判断是否满足<br><strong><em>零宽</em></strong> 的意思是它只匹配一个位置，如同^匹配开头，$匹配末尾，只是一个位置，不返回匹配到的字符<br><strong><em>正向</em></strong> 表示需要满足 pattern， 负向表示不能满足 pattern<br><strong><em>先行</em></strong> 表示这个断言语句出现在期望返回的匹配字符的后面。</p><ul><li><p><code>\\B</code>单词边界</p></li><li><p><code>?=</code>零宽正向先行断言，非获取匹配</p><blockquote><p><code>exp1(?=exp2)</code>，匹配<code>exp2</code>之前的<code>epx1</code> &gt; <code>&#39;fictioncompilerfiction&#39;.match(/fiction(?=compiler)/)</code>匹配 compiler 之前的 fiction，<strong>fiction</strong>compilerfiction</p></blockquote></li><li><p><code>?!</code>零宽负向先行断言，非获取匹配</p><blockquote><p><code>exp1(?!exp2)</code>，其意义是不是出现在<code>exp2</code>前面的<code>exp1</code><br><code>&#39;fictioncompilerfiction&#39;.match(/fiction(?!compiler)/)</code>匹配非 compiler 之前的 fiction，fictioncompiler<strong>fiction</strong></p></blockquote></li></ul><p>javascript 并不支持后行断言，但是浏览器支持（😂）</p><ul><li><p><code>?&lt;=</code>零宽正向后行断言，非获取匹配</p><blockquote><p><code>(?&lt;=exp1)exp2</code>，匹配<code>exp1</code>之后的<code>exp2</code><br><code>&#39;fictioncompilerfiction&#39;.match(/(?&lt;=)fiction/)</code>匹配 compiler 之后的 fiction，fictioncompiler<strong>fiction</strong></p></blockquote></li><li><p><code>?&lt;!</code>零宽负向后行断言，正向否定查询</p><blockquote><p><code>(?&lt;!exp1)exp2</code>，匹配不在<code>exp1</code>之后的<code>exp2</code><br><code>&#39;ficcomfic&#39;.match(/(?&lt;!com)fic/)</code>匹配不在 com 之后的 fic，<strong>fic</strong>comfic</p></blockquote></li><li><p><code>?:</code>非捕获组</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">表示捕获分组，</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">会把每个分组里的匹配的值保存起来，使用$n</span><span class="token punctuation">(</span>n是一个数字，表示第n个捕获组的内容<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token function">表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来</span><span class="token punctuation">(</span>但是会参与匹配<span class="token punctuation">)</span>，影响的是\\<span class="token number">1</span> \\<span class="token number">2</span>这种关键字的使用
如：
<span class="token operator">/</span><span class="token punctuation">(</span><span class="token operator">?</span><span class="token operator">:</span>Swift3<span class="token punctuation">)</span><span class="token punctuation">(</span>Swift4<span class="token punctuation">)</span>\\<span class="token number">1</span><span class="token operator">/</span>
<span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(Swift3)(Swift4)\\2</span><span class="token regex-delimiter">/</span></span>
上面两个是等价的
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ul><h2 id="非-获取匹配" tabindex="-1"><a class="header-anchor" href="#非-获取匹配" aria-hidden="true">#</a> （非）获取匹配</h2><ul><li><code>()</code>表示捕获分组，()会把每个分组里的匹配的值保存起来，使用$n(n 是一个数字，表示第 n 个捕获组的内容)</li><li><code>(?:)</code>表示非捕获分组，和捕获分组唯一的区别在于，非捕获分组匹配的值不会保存起来(但是会参与匹配)，影响的是\\1 \\2 $1 $2 这种关键字的使用</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">&#39;xuxi is xuxi is&#39;</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(xuxi) (is) \\1 \\2</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">;</span> <span class="token comment">//\\1即表示使用了存储的匹配(存储的第一个匹配)</span>
reg<span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>
str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>reg<span class="token punctuation">,</span> <span class="token string">&#39;$1 $2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// xuxi is</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="命名捕获组" tabindex="-1"><a class="header-anchor" href="#命名捕获组" aria-hidden="true">#</a> 命名捕获组</h2><h3 id="写法" tabindex="-1"><a class="header-anchor" href="#写法" aria-hidden="true">#</a> 写法</h3><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 普通捕获组</span>
<span class="token keyword">const</span> normalReg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(pattern)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token comment">// 命名捕获组，两种写法等价</span>
<span class="token keyword">const</span> namedReg01 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&lt;name&gt;pattern)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token keyword">const</span> namedReg02 <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">(?&#39;name&#39;pattern)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>

<span class="token comment">// 命名捕获组在字符串调用replace，replaceAll方法的时候，</span>
<span class="token comment">// 第二个参数是函数的时候（函数的最后一个参数）可以访问到</span>
<span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\d*(?&lt;name1&gt;4)</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">;</span>
<span class="token string">&#39;123456789&#39;</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">\\d+(?&lt;name1&gt;4)</span><span class="token regex-delimiter">/</span><span class="token regex-flags">g</span></span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> arg<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出一个Array&lt;{[key:string]: string}&gt;</span>
<span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token string-property property">&quot;name1&quot;</span><span class="token operator">:</span><span class="token string">&quot;4&quot;</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,12);function m(g,x){const a=t("ExternalLinkIcon");return o(),p("div",null,[r,u,n("p",null,[n("a",d,[s("link"),c(a)])]),k])}const b=e(l,[["render",m],["__file","base.html.vue"]]);export{b as default};
