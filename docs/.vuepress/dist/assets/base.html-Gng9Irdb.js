import{_ as a,r as i,o as c,c as l,a as e,b as t,d as r,f as d}from"./app-5uqBhi11.js";const s={},n={id:"toturial",tabindex:"-1"},p=e("a",{class:"header-anchor",href:"#toturial","aria-hidden":"true"},"#",-1),u={href:"https://git-scm.com/book/zh/v2",target:"_blank",rel:"noopener noreferrer"},h=d(`<h2 id="git命令" tabindex="-1"><a class="header-anchor" href="#git命令" aria-hidden="true">#</a> git命令</h2><blockquote><p><code>git add .</code><br><code>git commit -m &lt;message: string&gt;</code><br><code>git commit -amend</code> 本次的提交追加在上次的提交里面合为一次，必须在git add .之后才能执行本命令<br><code>git remote add origin &lt;url&gt;</code> 添加远程仓库的地址<br></p></blockquote><h3 id="删除命令" tabindex="-1"><a class="header-anchor" href="#删除命令" aria-hidden="true">#</a> 删除命令</h3><ol><li><code>git branch -D &lt;branch_name&gt;</code><blockquote><p>删除本地仓库的某个分支</p></blockquote></li><li><code>git push &lt;repository_name&gt; :&lt;branch_name&gt; </code><blockquote><p>同样是删除远程分支的另一种方法</p></blockquote></li><li><code>git push &lt;repository_name&gt; --delete &lt;branch_name&gt; </code><blockquote><p>删除远程的某个分支</p></blockquote></li><li><code>git push rm &lt;repository_name&gt; </code><blockquote><p>删除远程的某个仓库</p></blockquote></li><li><code>git rm &lt;_path&gt;</code><blockquote><p>同时从工作区和索引中删除文件。即本地的文件也被删除了</p></blockquote></li><li><code>git rm --cached &lt;_path&gt;</code><blockquote><p>从索引中删除文件。但是本地文件还存在， 只是不希望这个文件被版本控制</p></blockquote></li></ol><h3 id="仓库相关命令" tabindex="-1"><a class="header-anchor" href="#仓库相关命令" aria-hidden="true">#</a> 仓库相关命令</h3><ol><li><code>git fetch &lt;repository_name&gt; </code><blockquote><p>同步远程服务器数据到本地</p></blockquote></li><li><code>git remote show </code><blockquote><p>可以查看到远程有多少仓库</p></blockquote></li><li><code>git remote -v </code><blockquote><p>可以查看远程仓库以及其对应的仓库地址</p></blockquote></li><li><code>git remote show &lt;repository_name&gt; </code><blockquote><p>查看远程的指定仓库</p></blockquote></li><li><code>git remote rename pb Paul </code><blockquote><p>修改某个远程仓库在本地的简称<br></p></blockquote></li></ol><h3 id="分支相关命令" tabindex="-1"><a class="header-anchor" href="#分支相关命令" aria-hidden="true">#</a> 分支相关命令</h3><ol><li><code>git branch -vv </code><blockquote><p>查看本地分支对应的远程分支<br></p></blockquote></li><li><code>git branch -a </code><blockquote><p>查看所有的本地及远程分支<br></p></blockquote></li><li><code>git branch -v </code><blockquote><p>查看各个分支最后一个提交信息<br></p></blockquote></li><li><code>git remote prune &lt;repository_name&gt; </code><blockquote><p>清楚远程仓库的无效分支（远程删除了，但是本地还有之前记录）</p></blockquote></li></ol><h3 id="取消提交" tabindex="-1"><a class="header-anchor" href="#取消提交" aria-hidden="true">#</a> 取消提交</h3><ol><li>git reset --hard &lt;commit_id&gt; <blockquote><p>彻底回退到commit_id的版本，本地源码页恢复到commit_ id版本（撤销commit和add）<br></p></blockquote></li><li>git reset --soft &lt;commit_id&gt; <blockquote><p>回退到commit_id版本，但是本地的修改可以提交（撤销commit但是add保留）<br></p></blockquote></li><li>git reset &lt;commit_id&gt; <blockquote><p>默认使用--mixed选项，回退到commit_id版本，修改的文件需要git add后才能提交<br></p></blockquote></li><li>git checkout &lt;commit_id&gt; &lt;file_name&gt; <blockquote><p>取消&lt;file_name&gt;的&lt;commit_id&gt;版本提交 <br></p></blockquote></li></ol><h3 id="修改提交" tabindex="-1"><a class="header-anchor" href="#修改提交" aria-hidden="true">#</a> 修改提交</h3><p>git commit --amend</p><blockquote><p>修改最后一次提交。先git add 新的changes，然后再跑这个命令重新提交<br> 如何撤销--amend的某次提交</p><blockquote><p>git reflog 查看提交的历史记录，区别于git log<br> git reset HEAD@{&lt;number&gt;} reset到指定的commit_hash</p></blockquote></blockquote><h3 id="合并提交" tabindex="-1"><a class="header-anchor" href="#合并提交" aria-hidden="true">#</a> 合并提交</h3><p>git rebase -i HEAD~&lt;number&gt; git rebase -i (startHash, endHash]</p><blockquote><p>number需要合并的commit的个数，从当前位置向前推</p></blockquote><h3 id="暂存修改" tabindex="-1"><a class="header-anchor" href="#暂存修改" aria-hidden="true">#</a> 暂存修改</h3><p>git stash save -a &lt;message_info&gt;</p><blockquote><br></blockquote><p>git stash list</p><blockquote><p>展示所有的stash<br> git stash pop --index stash@{0} 取出指定index的stash，并在stash list中清除<br> git stash apply --index stash@{0} apply指定index的stash，stash list中仍然存在<br> git stash clear 清除所有的stash<br></p></blockquote><h3 id="reset" tabindex="-1"><a class="header-anchor" href="#reset" aria-hidden="true">#</a> reset</h3><p>git reset HEAD .</p><blockquote><p>在git add .之后可以用来撤销暂存的文件<br></p></blockquote><h3 id="checkout" tabindex="-1"><a class="header-anchor" href="#checkout" aria-hidden="true">#</a> checkout</h3><blockquote><p>将HEAD指向某个分支的最近一次commit, 从commit恢复index, 从index恢复工作区(浅层理解的话,index就是暂存区), 但是处于安全考虑, 只会放弃工作区的改动, 暂存区保留, 除非加上-f参数</p></blockquote><ol><li><code>git checkout .</code><blockquote><ol><li>切换到当前分支,并指向最新的commit</li><li>将commit恢复到暂存区</li><li>将暂存区的内容恢复到工作区 <strong>等价于git restore .</strong> 撤销所有未<code>git add</code>的更改</li></ol></blockquote></li><li><code>git checkout -f .</code><blockquote><p>撤销暂存区和工作区中的所有改动</p></blockquote></li></ol><h3 id="clean" tabindex="-1"><a class="header-anchor" href="#clean" aria-hidden="true">#</a> clean</h3><p>git clean -f</p><blockquote><p>删除所有的untracked files<br> git clean -fd 删除所有的untracked files &amp; untracked directory<br> git clean -xfd 连 gitignore 的untrack 文件/目录也一起删掉 （慎用，一般这个是用来删掉编译出来的 .o之类的文件用的）<br> 在用上述 git clean 前，墙裂建议加上 -n 参数来先看看会删掉哪些文件，防止重要文件被误删</p></blockquote><h3 id="tag" tabindex="-1"><a class="header-anchor" href="#tag" aria-hidden="true">#</a> tag</h3><ol><li><code>git tag {tagName} [-m &#39;tag message&#39;] [commitId]</code><blockquote><p>新增一个tag</p></blockquote></li><li><code>git tag -l</code><blockquote><p>查看所有tag</p></blockquote></li><li><code>git show {tagName}</code><blockquote><p>查看某个tag 的具体信息</p></blockquote></li><li><code>git push origin {tagName}</code><blockquote><p>将某个tag推送到远程仓库</p></blockquote></li><li><code>git push origin --tags</code><blockquote><p>将所有的tags推送到远程仓库</p></blockquote></li><li><code>git tag -d {tagName}</code><blockquote><p>删除本地某个tag</p></blockquote></li><li><code>git push origin :refs/tags/{tagName}</code><blockquote><p>删除远程标签 <code>git push --delete origin {tagName}</code></p></blockquote></li><li><code>git ls-remote --tags origin</code><blockquote><p>查看远程所有tags</p></blockquote></li></ol><h3 id="restore" tabindex="-1"><a class="header-anchor" href="#restore" aria-hidden="true">#</a> restore</h3><ol><li><code>git restore [.] | [fileName]</code><blockquote><p>放弃所有已track但是未add的文件的所有更改(即不在暂存staged中的更改)</p></blockquote></li><li><code>git restore --staged [.] | [fileName]</code><blockquote><p>将所有|某个已暂存的文件修改从暂存区取出</p></blockquote></li></ol><h2 id="window" tabindex="-1"><a class="header-anchor" href="#window" aria-hidden="true">#</a> window</h2><ol><li>从一个git repo切换到另一个git repo的时候，没有要求重新输入密码，导致认证失败</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// cmd中使用用管理员权限运行 </span>
git config <span class="token operator">--</span>system <span class="token operator">--</span>unset credential<span class="token punctuation">.</span>helper
<span class="token comment">// vscode中使用</span>
git config <span class="token operator">--</span>global <span class="token operator">--</span>unset credential<span class="token punctuation">.</span>helper 
<span class="token comment">// 如果还不行</span>
git config –<span class="token operator">-</span>global http<span class="token punctuation">.</span>emptyAuth <span class="token boolean">true</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>vscode记住git 账号</li></ol><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>git config <span class="token operator">--</span>global credential<span class="token punctuation">.</span>helper store
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,39);function b(g,m){const o=i("ExternalLinkIcon");return c(),l("div",null,[e("h2",n,[p,t(),e("a",u,[t("toturial"),r(o)])]),h])}const q=a(s,[["render",b],["__file","base.html.vue"]]);export{q as default};
